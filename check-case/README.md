# ЧекСканер. 18-04-2025
## Вводный раздел
ЧекСканер - серверное веб-приложение для обработки чеков из ресторанов.

__Цели проекта__:
1. Реализовать обработку и парсинг чека по позициям.
2. Создать модель для обработки сессий из нескольких пользователей (Всех пользоватлей, участвующих в оплате одного чека).
3. На практике реализовать модель в базе данных и подготовить сервис к работе с ней.
4. Подготовить удобный, модульный пользовательский интерфейс к работе с websocket.
5. Настроить серверно-клиентское взаимодействие пиложения.

__Задачи проекта__:
1. Подготовить изображение для работы easyOCR с помощью инструментов opencv. Вырезать чек, удалить лишнее с изображения, повернуть и исправить паралакс.
2. Подобрать оптимальные настройки easyOCR для обработки чека по позициям.
3. Парсить чек, находя по ключевым словам соотвутствующие им столбцы.
4. Реализовать при помощи Python и sqlite3 методы для абстрактной работы с базой данных.
5. Использовав flask и методы из пункта (4), создать view-controller для общения с клиентской частью через websocket.
6. Создать макет клиентской части будующего веб-сервиса.
7. Подключить макет к серверной части сервиса используя сигналы из созданные в пункте (5).

__Используемые библиотеки/модули/модели__:
* __flask__ - компактный по сравнению с django фреймворк. Выбран как наиболее уместный для небольшого веб-сервиса.
* __flask-socketIO__ - модуль для flask, позволяющий реализовывать технологию websocket для поддержания клиент-серверной связи.
* __flask-cors__ - модуль, использующийся для настройки CORS (Cross-origin resource sharing).
* __sqlite3__ - компактная и легкая встраиваемая база данных, которая позволяет хранить и управлять данными прямо внутри вашего приложения. При расширении проекта разумно будет замена на более мощную БД, например такую как PostgreSQL. Используется в демонстрационных целях, ведь одним из главных достоинств sqlite явлется serverless подход, что позволяет проще развернуть приложение.
* __jaiden easyOCR__ - модель для распознования текста. Выбрана как наиболее гибкая модель, поддерживающая множество языков, а также имеющая возможность дообучения.
* __opencv__ - модуль необходимый для работы easyOCR, а также для подготовки изображения к процессу оптического распознования символов. Благодаря первичной обработке чека (Маска, поворот и т.п.) удаётся получить более стабильный результат. Используется как на клиентской, так и на серверной части.
* __JQuery__ - для работы с DOM элементами.
* __qrcode__ - для удобного создания qr-кода.

__Демонстрация работы__
1. Откроем приложение. Для запуска локально скопируйте репозиторий, после чего выполните следующие команды (Убедитесь, что исползуете виртуальное окружение предед установкой).
<pre>
  pip install -r requirements.txt
  python3 run.py
</pre>
Так выглядит приложение для пользователя с типом 'HOST', оно же открывается автоматически если не передавать никаких ключей в url. Первое, что предстоит сделать любому пользователю - это ввести своё имя, после чего оно сохраниться в localstorage, также как и выбор темной/светлой темы приложения.
<img src="https://raw.githubusercontent.com/ArtemijKarandashov/check-case/refs/heads/dev/screenshots/1.jpg"><br>
2. После подтверждения имени, пользователю будет предложено разместить фото чека (или сделать новое). Далее начнётся этап подготовки чека к OCR,  поэтому нужно будет подождать несколько секунд. Использованый пример чека можно найти на github репозетории в директории examples/
<img src="https://raw.githubusercontent.com/ArtemijKarandashov/check-case/refs/heads/dev/screenshots/2.jpg"><br>
3. После завершения подготовки чека пользователю будет предложено поделиться QR-кодом/ссылкой со своими друзьями. В этот же момент на сервере будет создана новая сессия, и сразу же начнется процесс обработки чека с помощью easyOCR с дальнейшим парсингом по позициям.
<img src="https://raw.githubusercontent.com/ArtemijKarandashov/check-case/refs/heads/dev/screenshots/3.jpg"><br>
4. Теперь, взглянем как будет выглядить приложение, если мы перейдем по данному qr-коду/ссылке.
Добавим таким образом 3 пользоватлей: Anton, Misha, Lesha
<br>
<br>
4.1 Добавляем пользоватлея Anton
<img src="https://raw.githubusercontent.com/ArtemijKarandashov/check-case/refs/heads/dev/screenshots/4.jpg">
<br>
4.2 Добавляем пользоватлея Misha
<img src="https://raw.githubusercontent.com/ArtemijKarandashov/check-case/refs/heads/dev/screenshots/5.jpg">
<br>
4.3 Добавляем пользоватлея Lesha
<img src="https://raw.githubusercontent.com/ArtemijKarandashov/check-case/refs/heads/dev/screenshots/6.jpg"><br>
5. После подтверждения имени новым пользователем он будет подключен к сессии хоста, который поделился ссылкой. Надпись на кнопке измениться на 'Подключено!', если все пройдёт успешно. 
<img src="https://raw.githubusercontent.com/ArtemijKarandashov/check-case/refs/heads/dev/screenshots/7.jpg"><br>
6. Вернемся к хосту сессии. Когда процесс обработки чека завершиться и хост нажмет на кнопку 'Продолжить' под qr-кодом откроется следующая панель (Пользователи все ещё могут пользоваться qr-кодом/ссылкой). Теперь хосту будет предложено выбрать метод распределения чека: процентный или по позициям.
<br>
<br>
6.1 Процентный метод предлагает установить (вручную или автоматически) долю каждому из пользователей. Когда процентный метод будет выбран в первый раз, доли автоматически распределятся поровну между участниками сессии (Если к сессии подключится кто то ещё, то проценты будут пересчитаны).
<img src="https://raw.githubusercontent.com/ArtemijKarandashov/check-case/refs/heads/dev/screenshots/8.jpg">
<br>
6.2 Метод распределения по позициям предложит хосту сессии самому выбрать кто платит за каждое из блюд (Можно указать несколько человек на одно блюдо). Изначально за каждое блюдо платят все участники сессии, что позволяет при желании также как и процентном методе, распределить чек поровну.
<img src="https://raw.githubusercontent.com/ArtemijKarandashov/check-case/refs/heads/dev/screenshots/9.jpg"><br>
7. Итак, когда хост настроит выбранный метод распределения и нажмет кнопку 'Подтвердить распределение' будет выведено оповещение, в котором указаны все участники сессии их платежи по чеку.
<img src="https://raw.githubusercontent.com/ArtemijKarandashov/check-case/refs/heads/dev/screenshots/10.jpg">
<br>
Обычные участники сессии получают менее информативное оповещение, в котором указан лишь их платеж.
<img src="https://raw.githubusercontent.com/ArtemijKarandashov/check-case/refs/heads/dev/screenshots/11.jpg">

## Раздел "Сервер"
Серверная часть приложения в основном занимается менеджементов пользоватлей, сессий и соединений между ними (А также OCR, но об этом подробнее в следующем разделе). Рассмотрим сигналы обрабатываемые через websocket:

### Сигналы принимаемые сервером
* __event 'connect'__ - Срабатывает, когда пользователь открывает страницу.
* __event 'disconnect'__ - Срабатывает, когда пользователь покидает страницу.
* __event 'login'__ - Подключает пользователя если передано его имя ({'name':имя}).
* __event 'logout'__ - Отключает пользователя, если он подключен.
* __event 'create_session'__ - Создаёт сессии, принимает json с полями {'type':'тип', 'ph_users': число_ненастоящих_пользователей}. 
    Создаёт сессию заданого типа 'type' ('DEFAULT','SINGULAR') с количеством ненастоящих пользователей 'ph_users' (Если таковые указаны).
* __event 'join_session'__ - Принимает ключ сессии, по которому подключает пользователя как CLIENT.
    Если пользователь не залогинен или уже состоит в другой сессии, то вернет ошибку
* __event 'proccess_check'__ - Запускает сессию в работу, обрабатывает сигнал, только если пользователь имеет тип HOST.
    На данный момент не реализован функционал. Входные данные могут измениться
* __event 'update_users_list'__ - При вызове возвращает текущий состав сессий. 
    Необходимо передать сессионый ключ ({session_key:ключ})
* __event 'distribution_results'__ - Отправляет результаты распределения чека всем участникам сессии. 
    Необходимо передать сессионый ключ и результаты распределения в формате ({session_key:ключ,results:{id:ид,amount:сумма}})
* __event 'request_html'__ - сигнал, запращивающий загрузку html темплейта.
  Необходимо указать имя html темплейта, требование, а также позицию для функции insertAdjacentHTML()
* __event 'request_script'__ - сигнал, запращивающий загрузку скрипта.
  Необходимо указать имя html темплейта, требование
<br/>
Под требованием понимается любой другой файл, который был запрошен с сервера ранее (Необходимо для соблюдения порядка загрузки элементов)
<br/>
### Сигналы отправляемые сервером</h2>
* __event 'login_success'__ - Возвращается если операция авторизации прошла успешно. 
    Содержит json {'message': 'You are connected!', 'name': 'имя', 'type': 'тип'}
* __event 'logout_success'__ - Возвращается при отключении пользователя от системы.
    Содержит json {'message': 'You are disconnected!'}
* __event 'user_connected'__ - Возвращается всем пользователям одной сессии, когда к ней подключается кто то еще.
    Содержит json {'message': 'User connected!','name': 'имя'}
* __event 'user_left_session'__ - Возвращается при отключении пользователя от сессии всем её участникам 
    Содержит json {'message': 'User left!'}
* __event 'send_session_key'__ - Взвращается при создании новой сессии её хосту.
    Содержит json {'message': 'Session created!','session_key': 'ключ_сессии'}
* __event 'error'__ - Возвращается при ошибке во время обработки любого из запросов, принятого сервером.
    Содержит json {'message': 'ошибка'}.
* __event 'load_html'__ - сигнал для динамической подгрузки html темплейтов.
* __event 'load_script'__ - сигнал для динамической подгрузки скриптов.

Вся работа с базой данных происходит через методы описанные в классе ConnectionManager. Объект этого класса является одиночкой, тоесть при попытке повторного создания вернется оригинальный объект.

### База данных
База данных состоит из трех таблиц: user, session, connection. Их атрибуты, а также внешние ключи можно наблюдать на следующей ER-диаграмме.
<img src="https://raw.githubusercontent.com/ArtemijKarandashov/check-case/refs/heads/dev/screenshots/ER.jpg">

Таблица user:
* __user_id__ - уникальный идентификатор пользователя (PK)
* name - имя пользователя
* type - тип пользователя. Может быть установлен как 'HOST', 'CLIENT' или 'PHANTOM'. Тип 'HOST' назначается пользователю, который создал новую сессию (Тоесть просканировал чек), а 'CLIENT' назначается всем, кто присоединился по QR-коду/ссылке. Тип 'PHANTOM' используется для 'ненастоящих' пользователей, которых хост сессии может добавить вручную, для этого типа не выполняются сигналы socketio, но они все ещё участвуют в расчетах чека, что позволяет хосту в одиночку обработать чек.
* sid - сессионый ид пользователя. Используется для работы с websocket.

<br/>Таблица session
* __session_id__ - уникальный идентификатор сессии (PK)
* session_key - ключ подключения к сессии
* status - статус выполнения обработки чека в сессии (0 - обработка не стартовала, 1 - в работе, 2 - обработка завершена)
* stype - тип сессии. ('DEFAULT' - обычная сессия, 'SINGULAR' - сессия содержащая только пользователя 'HOST' и ненастоящих пользователей 'PHANTOM')

<br/>Таблица connection
* __connection_id__ - уникальный идентификатор подключения (PK)
* __session_key__ - внешний ключ, содержащий ключ подключения сессии из таблицы session. Каскадное удаление и обнавление.
* __user_id__ - внешний ключ, содержащий идентификатор пользователя. Каскадное удаление и обнавление.

Эта простая система позволяет группировать пользователей внутри одной сессии и работать с ними изолированно.
Также, при расширении, возможно интегрировать внешнуюю авторизационную систему и сохронять пользоватлей (А не удалять их как это происходит в демонстрационной версии). 

## Раздел "OCR"

Этот набор функций используется для распознавания текста с изображений чеков с помощью библиотеки EasyOCR, а затем — для извлечения:

* Общей суммы по чеку.
* Перечня заказанных блюд (наименования, количество, стоимость).

---

### Функция get_ocr_data(reader: easyocr.Reader(), img_path: str, **kwargs) -> list:

### Назначение

Распознаёт текст с изображения чека, используя EasyOCR.

### Аргументы

* reader (easyocr.Reader): Экземпляр Reader, настроенный на русский язык.
* img_path (str): Путь к изображению чека.
* **kwargs: Зарезервированы для будущего использования (пока не используются).

### Процесс

* Использует reader.readtext() для анализа изображения.
* Параметры width_ths и height_ths управляют фильтрацией и масштабом анализа.

### Возвращает

Список кортежей: [(bounding_box, text, confidence), ...].

---

### Функция get_total_sum(data: list) -> dict[str: float]:

### Назначение

Извлекает итоговую сумму из списка распознанных строк (результатов OCR).

### Аргументы

* data (list): Результаты OCR — список кортежей.

### Процесс

* Преобразует текст в нижний регистр и убирает лишние пробелы.
* Ищет ключевые слова: "итог", "всего", "к оплат".
* После ключевого слова пытается найти сумму в ближайших строках (возможно на строку или две дальше).
* При необходимости извлекает число, даже если оно было объединено с текстом при распознавании.

### Возвращает

Словарь с найденной суммой: {"sum": 285.50}
Или None, если сумма не найдена.

---

### get_servings(data: list) -> list:

### Назначение

Извлекает позиции из чека: наименование блюда, количество и цену за единицу.

### Аргументы

* data (list): Результаты OCR — список кортежей с bounding box и текстом.

### Процесс

<ol>
    <li>
        Ищет заголовки колонок: наименования, количество, сумма.
    </li>
    <li>
        Вычисляет границы колонок по координатам (bounding boxes).
    </li>
    <li>
        Переходит к строкам после заголовков и начинает извлекать информацию:
    </li>
        <ul>
            <li>
                Определяет, какой текст к какой колонке относится по положению.
            </li>
            <li>
                Обрабатывает случаи слипшихся данных (например, Котлета 2 150.00).
            </li>
        </ul>
    <li>
        Если позиция содержит количество > 1, пересчитывает цену за единицу.
    </li>
</ol>

### Возвращает

Список словарей с позициями блюд:
Ключи:

* 'name'
* 'amount'
* 'sum'

---

### Вспомогательная функция is_numeric(s: str) -> bool:

Функция проверяет, можно ли строку интерпретировать как число (int или float).

## Раздел "Клиент"
Основная задача клиентской части приложения это подготовить чек к обработке. Это достигается при помощи библиотеки opencv для javascript.

### Функция extractImage(img)

### Назначение
Выполняет автоматическое выделение и выравнивание объекта на изображении

### Аргументы

* img: изображение для предобработки

### Загрузка изображения и подготовка
```javascript
let src = cv.imread(img);
let original = new cv.Mat();
cv.cvtColor(src, src, cv.COLOR_RGBA2RGB);
cv.cvtColor(src, original, cv.COLOR_RGBA2RGB);
```
cv.imread(img) — загружает изображения в объект Mat.
<br>
Преобразование RGBA в RGB избавляет от альфа-канала.
<br>
original — копия исходного изображения для финальной трансформации.

### Морфологическая фильтрация
```javascript
cv.morphologyEx(src, src, cv.MORPH_CLOSE, kernel);
```
Морфологическая операция помогает устранить шум и объединить разорванные контуры, заполняя мелкие пробелы.

### Разделение переднего и заднего плана (GrabCut)
```javascript
let mask = new cv.Mat.zeros(src.rows, src.cols, cv.CV_8U);
let bgdModel = new cv.Mat();
let fgdModel = new cv.Mat();
let rect = new cv.Rect(50, 50, src.cols - 70, src.rows - 70);
cv.grabCut(src, mask, rect, bgdModel, fgdModel, 5, cv.GC_INIT_WITH_RECT);
```
Алгоритм GrabCut выделяет передний план (чек) от фона.
<br>
mask и модели bgdModel и fgdModel управляют сегментацией.
<br>
rect — прямоугольная область, в которой предположительно находится объект интереса (чек).

### Маска
```javascript
for (...) {
    mask.ucharPtr(i, j)[0] = (val === 2 || val === 0) ? 0 : 255;
}
```
Маска преобразуется в фильтр: пиксели, не принадлежащие объекту интереса (чеку) (val = 0 или 2), становятся чёрными (0), остальные — белыми (255).
<br>
Получаем чёрно-белую маску переднего плана.

### Выделение объекта по маске
```javascript
cv.bitwise_and(src, src, fg, mask);
```
Маска накладывается на изображение, удаляя фон и оставляя только передний план (чек).

### Контурный анализ
```javascript
cv.cvtColor(fg, gray, cv.COLOR_RGBA2GRAY);
cv.GaussianBlur(gray, gray, new cv.Size(11, 11), 0);
```
Полученное изображение преобразуется в оттенки серого.
<br>
Применяется размытие, чтобы уменьшить шум перед поиском контуров.

```javascript
let contours = new cv.MatVector();
let hierarchy = new cv.Mat();
cv.findContours(gray, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
```
Находятся внешние контуры на изображении.

```javascript
for (...) {
    cv.approxPolyDP(c, approx, 0.02 * peri, true);
    if (approx.rows === 4) break;
}
```
При помощи алгоритма Рамера (Дугласа - Пекера) находится границы контуры чека.
<br>
approxPolyDP используется для аппроксимации контура: если найден четырёхугольник (4 точки), то это может быть документ.

### Упорядочивание точек и расчёт размеров
```javascript
let points = [...]; // Сбор координат 4 точек
let ordered = orderPoints(points); // Упорядочиваем как tl, bl, br, tr
```
Так как мы не можем быть уверены, что точки углов чека расположены в нужном нам порядке, то используется функция orderPoints. Она сортирует точки в порядке против часовой стрелки начиная с верхнего левого угла.

```javascript
let widthA = Math.hypot(br[0] - bl[0], br[1] - bl[1]);
let widthB = Math.hypot(tr[0] - tl[0], tr[1] - tl[1]);
let maxWidth = Math.max(Math.floor(widthA), Math.floor(widthB));

let heightA = Math.hypot(tr[0] - br[0], tr[1] - br[1]);
let heightB = Math.hypot(tl[0] - bl[0], tl[1] - bl[1]);
let maxHeight = Math.max(Math.floor(heightA), Math.floor(heightB));
```
По найденным углам рассчитывается ширина и высота изображения чека. На их основе, к оригинальному изображению применяется трансформация перспективы.

### Перспективное преобразование
```javascript
let M = cv.getPerspectiveTransform(srcTri, dstTri);
cv.warpPerspective(original, dst, M, new cv.Size(maxWidth, maxHeight));
```
Создаём матрицу преобразования перспективы.
<br>
Применяем её к оригинальному изображению для получения изображение минимальными искажениями, вызванными поворотом относительно камеры и параллаксом.

### Возвращает

Матрица изображения: [[[255, 255, 255], [...], ...], ...]

---

### Функция convertMat2Base64(img, mimeType = 'image/jpeg')

### Назначение

Преобразует изображение в формате cv.Mat (OpenCV.js) в строку base64, представляющую изображение в формате, пригодном для отображения или передачи по сети.

### Аргументы

* img (cv.Mat): Изображение в формате OpenCV.js (cv.Mat), которое необходимо преобразовать. Ожидается, что изображение в RGB-формате.
* mimeType (string, необязательный): MIME-тип выходного изображения. По умолчанию 'image/jpeg'. Можно указать 'image/png' или другой поддерживаемый формат.

### Процесс

Функция преобразует изображение из RGB в RGBA, чтобы соответствовать формату, используемому canvas.

```javascript
cv.cvtColor(img, img, cv.COLOR_RGB2RGBA);
```

Создаётся элемент <canvas> с размерами изображения (img.cols и img.rows), соответствующими ширине и высоте.

```javascript
const canvas = document.createElement('canvas');
canvas.width = img.cols;
canvas.height = img.rows;
```

С помощью контекста 2D (canvas.getContext('2d')) создаётся пустой объект ImageData. В него копируются пиксельные данные из img.data, полученные от OpenCV.

```javascript
const ctx = canvas.getContext('2d');
const imgData = ctx.createImageData(img.cols, img.rows);
imgData.data.set(img.data);
```

Полученные данные ImageData вставляются в canvas через putImageData.

```javascript
ctx.putImageData(imgData, 0, 0);
```

Метод canvas.toDataURL(mimeType) генерирует строку в формате Data URL — это изображение, закодированное в base64 с указанным MIME-типом.

```javascript
return canvas.toDataURL(mimeType);
```

### Возвращает

string: Строка изображения в формате Base64 (Data URL), готовая для отправки на сервер.
